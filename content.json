{"meta":{"title":"ElaineLiu's Blog","subtitle":null,"description":null,"author":"ElaineLiu","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"React中的setState没有想象中简单","slug":"react-setState","date":"2019-03-20T09:59:39.741Z","updated":"2019-03-20T09:59:23.916Z","comments":true,"path":"2019/03/20/react-setState/","link":"","permalink":"http://yoursite.com/2019/03/20/react-setState/","excerpt":"","text":"最近看到一些文章关于setState的用法，在这里做一个笔记。 setState不为人知的参数第一个参数：不仅能接受一个对象，还能接受一个函数该函数接受该组件前一刻的 state 以及当前的 props 作为参数，计算和返回下一刻的 state：12345this.setState(function (state, props) &#123; return &#123; score: state.score - 1 &#125;&#125;); 第二个参数：返回当前计算后的state状态12345handle() &#123; this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;), () =&gt; &#123; console.log(this.state) &#125;)&#125; setState是同步还是异步？作为一个react初学者，看过一些文章之后我才发现setState是有异步和同步的区分的，所以如果没有很深入的去研究一个框架，很多东西你学会的也是表面的。生命周期中的setState12345678910111213141516171819class App extends Component &#123; state=&#123; count:0 &#125; componentDidMount()&#123; this.setState((prevState) =&gt;(&#123; count:prevState.count+1 &#125;),()=&gt;&#123;console.log(\"setState\",this.state)&#125; // 后输出 setState &#123;count: 1&#125; ) console.log(this.state) // 先输出 &#123;count: 0&#125; &#125; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;button&gt;&#123;this.state.count&#125;&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; React引发的事件，如onClick/onChange1234567891011121314151617state=&#123; count:0 &#125; handle = () =&gt; &#123; this.setState((prevState) =&gt;(&#123; count:prevState.count+1 &#125;),()=&gt;&#123;console.log(\"setState\",this.state)&#125; // 输出修改后的值 ) console.log(this.state) // 输出上一个state的 &#125; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;button onClick=&#123;this.handle&#125;&gt;&#123;this.state.count&#125;&lt;/button&gt; &lt;/div&gt; ); &#125; 原生事件的setState:通过addEventListener添加的事件1234567891011121314151617181920state=&#123; count:0 &#125; handle = () =&gt; &#123; this.setState((prevState) =&gt;(&#123; count:prevState.count+1 &#125;),()=&gt;&#123;console.log(\"setState\",this.state)&#125; // 两次输出一致，都是修改后的state值 ) console.log(this.state) // 两次输出一致，都是修改后的state值 &#125; componentDidMount()&#123; document.getElementById('myBtn').addEventListener('click',this.handle) &#125; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;button id='myBtn'&gt;&#123;this.state.count&#125;&lt;/button&gt; &lt;/div&gt; ); &#125; setTimeout/setInterval中的setState12345678910111213141516171819state=&#123; count:0 &#125; componentDidMount()&#123; setTimeout(()=&gt;&#123; this.setState(&#123; count:this.state.count+1 &#125;) console.log(\"1\",this.state)// 修改后的state值 &#123;count: 1&#125; &#125;,1000) console.log(\"2\",this.state) // &#123;count: 0&#125; &#125; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;button id='myBtn'&gt;&#123;this.state.count&#125;&lt;/button&gt; &lt;/div&gt; ); &#125; setState的批量合并看到一些文章说setState遇到批量更新的会合并，，其实，是分以下两种写法的1234this.setState(&#123; count: this.state.count + 1 &#125;)this.setState(&#123; count: this.state.count + 1 &#125;)this.setState(&#123; count: this.state.count + 1 &#125;)// 这种情况是会合并且只执行最后一次 1234this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))// 这种情况是输出的值是三次累加的结果 例子：在React引起的事件12345678910111213141516171819state=&#123; count:0 &#125; handle = () =&gt; &#123; this.setState(&#123; count:this.state.count+1 &#125;) this.setState(&#123; count:this.state.count+1 &#125;) // 每次只加1 &#125; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;button onClick=&#123;this.handle&#125;&gt;&#123;this.state.count&#125;&lt;/button&gt; &lt;/div&gt; ); &#125; 12345678910111213141516171819state=&#123; count:0 &#125; handle = () =&gt; &#123; this.setState((prevState) =&gt;(&#123; count:prevState.count+1 &#125;)) this.setState((prevState) =&gt;(&#123; count:prevState.count+1 &#125;)) // 每次加2 &#125; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;button onClick=&#123;this.handle&#125;&gt;&#123;this.state.count&#125;&lt;/button&gt; &lt;/div&gt; ); &#125; 在生命周期中12345678componentDidMount () &#123; this.setState(&#123; count:this.state.count+1 &#125;) this.setState(&#123; count:this.state.count+1 &#125;) &#125; 12345678componentDidMount () &#123; this.setState((prevState) =&gt;(&#123; count:prevState.count+1 &#125;)) this.setState((prevState) =&gt;(&#123; count:prevState.count+1 &#125;))&#125; 在setTimeout中1234567891011121314151617181920componentDidMount () &#123; setTimeout(()=&gt;&#123; this.setState(&#123; count:this.state.count+1 &#125;) this.setState(&#123; count:this.state.count+1 &#125;) this.setState(&#123; count:this.state.count+1 &#125;) &#125;,1000) &#125; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;button &gt;&#123;this.state.count&#125;&lt;/button&gt; //3 &lt;/div&gt; ); &#125; 总结：1.setState为异步：在react的生命周期及由react引起的事件（onClick/onChange）中2.setState为同步：由原生事件引起的及在setTimeout/setInterval中3.setState批量操作是否会合并：当setState为异步时且参数为对象，取最后一次来执行，若参数为函数，则每一次都会计算；当setState为同步时，不管参数是对象还是函数，都会执行。","categories":[],"tags":[]},{"title":"Array的方法集锦","slug":"method-Array","date":"2019-03-20T09:59:01.758Z","updated":"2019-03-20T09:58:44.324Z","comments":true,"path":"2019/03/20/method-Array/","link":"","permalink":"http://yoursite.com/2019/03/20/method-Array/","excerpt":"","text":"Array.from:将声明的对象转为数组12let array = &#123;0:1,1:2,2:3,length:3&#125;Array.from(array) // [1,2,3] 区别于扩展运算符：…只能把拥有迭代器的伪数组转为数组，如arguments、map、set array.reduce():对数组进行某种操作，加减乘除，最后返回一个值123456let array=[1,2,3,4]//prev当前值，且会将这次累加结果作为下一次的prev值，current当前值，currentIndex当前索引，array数组let total=array.reduce((prev,current,currentIndex,array)=&gt;&#123; return prev+current&#125;)console.log(total) // 10 传入初始值：reduce第二个参数可以初始化prev的值12345let array=[1,2,3,4]let total=array.reduce((prev,current,currentIndex,array)=&gt;&#123; return prev+current&#125;,4)console.log(total) // 14 array.foreach():用于调用数组的每个元素，并将元素传递给回调函数1array.forEach(function(currentValue, index, arr), thisValue) array.map():数组返回成一个映射后的数组12let arr = [1,2,3].map(item =&gt; item+1)console.log(arr) // [2,3,4] array.every():数组都满足某条件则返回true,否则返回false12345let array=[1,2,3,4]let total=array.every(item=&gt;&#123; return item &lt; 0&#125;)console.log(total) // false array.find():返回第一个满足条件的值，若找不到则返回undefined； array.findIndex():返回第一个满足条件的值的位置，若找不到则返回-112345let array=[1,2,3,4]let total=array.find(item=&gt;&#123; return item&gt;2&#125;)console.log(total) // 3 array.some():是否有其中一个值满足条件，如果是则返回true，如果不是则返回false12345let array=[1,2,3,4]let total=array.find(item=&gt;&#123; return item&gt;2&#125;)console.log(total) // true array.filter():过滤掉返回为false的项，最后重新生成一个数组12345let array=[1,2,3,4]let total=array.filter(item=&gt;&#123; return item&gt;2&#125;)console.log(total) // [3,4] includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。123let array=[1,2,3,4]let total=array.includes(2)console.log(total) //true","categories":[],"tags":[]},{"title":"关于React你必须知道的事","slug":"react-something","date":"2019-03-20T09:58:27.617Z","updated":"2019-03-20T09:57:39.732Z","comments":true,"path":"2019/03/20/react-something/","link":"","permalink":"http://yoursite.com/2019/03/20/react-something/","excerpt":"","text":"一、React component的两种写法 函数式定义的无状态组件特点：没有state/生命周期123export default function App(props) &#123; return &lt;input /&gt;&#125; 2.ES6方式定义的组件12345class List extends React.Component &#123; render() &#123; return &lt;div&gt;我是一个es6方式定义的react组件&lt;/div&gt; &#125;&#125; 使用场景：—-无状态组件适用于纯展示或props传递渲染时 二、React.Component 绑定方法的几种方法1.在construct中绑定123456789101112class List extends React.Component &#123; constructor(props) &#123; super(props) this.onClickList = this.onClickList.bind(this) &#125; onClickList() &#123; console.log('我被点了') &#125; render() &#123; return &lt;div onClick=&#123;this.onClickList&#125;&gt;点我点我点我&lt;/div&gt; &#125;&#125; 2.在render中bind12345678class List extends React.Component &#123; onClickList() &#123; console.log('我被点了') &#125; render() &#123; return &lt;div onClick=&#123;this.onClickList.bind(this)&#125;&gt;点我点我点我&lt;/div&gt; &#125;&#125; 3.方法使用箭头函数，不需要bind12345678class List extends React.Component &#123; onClickList = () =&gt; &#123; console.log('我被点了') &#125; render() &#123; return &lt;div onClick=&#123;this.onClickList&#125;&gt;点我点我点我&lt;/div&gt; &#125;&#125; 4.render内用箭头函数12345678class List extends React.Component &#123; onClickList() &#123; console.log('我被点了') &#125; render() &#123; return &lt;div onClick=&#123;() =&gt; this.onClickList()&#125;&gt;点我点我点我&lt;/div&gt; &#125;&#125; 对于在方法上传参12&lt;button onClick=&#123;this.handleClick.bind(this, id)&#125; /&gt;&lt;button onClick=&#123;() =&gt; this.handleClick(id)&#125; /&gt; 三、为什么循环渲染组件的要加上keykey相同则后面的会被丢弃，不会渲染—- react根据key来决定是销毁重新创建组件还是更新组件 * key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。 * key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行） *不推荐使用map方法的index作为key，因为这个key不是唯一标识当前组件,最好使用后台返回的id 123456789101112131415161718192021222324252627282930class App extends React.Component&#123; state=&#123; data:[1,2,3,4] &#125; componentDidMount()&#123; //全部re-render setTimeout(()=&gt;&#123; this.setState(&#123; data:[4,1,2,3] &#125;)&#125;,10000) //只会re-render最后一个div setTimeout(()=&gt;&#123; this.setState(&#123; data:[1,2,3,5] &#125;)&#125;,10000) &#125; render()&#123; return( &lt;div&gt;&#123; this.state.data.map((item,index)=&gt;( &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt; )) &#125; &lt;/div&gt; ) &#125;&#125;export default App; 四、React的ref揭秘 ref的三种用法: 字符串(已废弃) ；回调函； React.createRef() （React16.3提供）1.字符串:要将获取dom节点写在未render之前的生命周期内，在render之前dom节点未渲染，会报错12345678handle=()=&gt;&#123; console.log(this.refs.textInput.value) &#125; render() &#123; return ( &lt;input ref=\"textInput\" onChange=&#123;this.handle&#125;/&gt; ) &#125; 2.回调函数：函数的参数是dom节点或组件实例，不能再render之前调用1234567891011121314class App extends Component &#123; componentDidMount() &#123; console.log(this.textInput.value) &#125; handle=()=&gt;&#123; console.log(this.textInput.value) &#125; render() &#123; return ( &lt;input ref=&#123;(inputs)=&gt;&#123;this.textInput=inputs&#125;&#125; onChange=&#123;this.handle&#125; /&gt; ) &#125;&#125;export default App; 3.React.createRef():this.myRef.current可以拿到input实例12345678910111213class App extends React.Component&#123; constructor(props)&#123; super(props); this.myRef=React.createRef(); &#125; componentDidMount()&#123; console.log(this.myRef.current.value); // 2 &#125; render()&#123; return &lt;input ref=&#123;this.myRef&#125; value='2'/&gt; &#125;&#125;export default App; 注意：ref在函数式组件上不可使用，函数式组件无实例 五、props/state/this.的区别props:父子组件之间的传递，且在子组件内不可更改state:当前组件内的状态，this.:当时面试官问我这个的时候我有点发懵，还有this.的用法？？回来一想，我觉得自己被props和state固话了一种模式，觉得组件中的数据只能存放在这两种模式下this.可以放定时器的id,组件内调用函数也是用this.方法(),this.setState({})参考：https://www.jianshu.com/p/4d2838ae7b29","categories":[],"tags":[]},{"title":"四种方法解决‘var’问题","slug":"method-var","date":"2019-03-20T09:58:25.336Z","updated":"2019-03-20T09:57:25.920Z","comments":true,"path":"2019/03/20/method-var/","link":"","permalink":"http://yoursite.com/2019/03/20/method-var/","excerpt":"","text":"var的经典问题123456// setTimeout是异步的，for执行完后i=6才会执行异步任务for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i);// 输出6个6 &#125;, i * 1000);&#125; 闭包+立即执行函数原理：1.闭包：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。B可以访问到A中的变量，因为A中的变量此时存放在堆中。2.立即执行函数：通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间1234567for (var i = 1; i &lt;= 5; i++) &#123; (function (i) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000); &#125;)(i)&#125; 使用setTimeout的第三个参数原理：setTimeout的第一个参数若是一个函数，则第三个参数会当做是该函数的参数传入12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer(i) &#123; console.log(i); &#125;, i * 1000,i);&#125; 用let代替var原理：let会形成块级作用域123456789101112131415161718192021222324252627for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125;// 实际流程 - 形成块级作用域&#123; let i = 0 &#123; let ii = i setTimeout(function timer() &#123; console.log(ii); &#125;, i * 1000); &#125; i++ &#123; let ii = i; setTimeout(function timer() &#123; console.log(ii); &#125;, i * 1000); &#125; i++ &#123; let ii = i; ... &#125; &#125; 用foreach的执行函数原理：foreach的执行函数形成了闭包12345[1,2,3,4,5].forEach(function(data,index,arr)&#123; setTimeout(function timer() &#123; console.log(data); &#125;, data * 1000); &#125;)","categories":[],"tags":[]}]}